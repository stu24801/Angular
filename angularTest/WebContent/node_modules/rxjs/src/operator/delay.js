"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('../scheduler/async');
var isDate_1 = require('../util/isDate');
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
var Observable_1 = require('../Observable');
this;
Observable_1.Observable < T > , delay;
number | Date,
    scheduler;
IScheduler = async_1.async;
Observable_1.Observable < T > {
    const: absoluteDelay = isDate_1.isDate(delay),
    const: delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay),
    return: this.lift(new DelayOperator(delayFor, scheduler))
};
var DelayOperator = (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber() {
        _super.apply(this, arguments);
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = ;
    return DelaySubscriber;
}(Subscriber_1.Subscriber));
void {
    const: source = state.source,
    const: queue = source.queue,
    const: scheduler = state.scheduler,
    const: destination = state.destination,
    while: function (queue, length) {
        if (length === void 0) { length =  > 0 && (queue[0].time - scheduler.now()) <= 0; }
        queue.shift().notification.observe(destination);
    },
    if: function (queue, length) {
        if (length === void 0) { length =  > 0; }
        var delay = Math.max(0, queue[0].time - scheduler.now());
        this.schedule(state, delay);
    }, else: {
        source: .active = false
    }
};
constructor(destination, Subscriber_1.Subscriber < T > , private, delay, number, private, scheduler, IScheduler);
{
    _super.call(this, destination);
}
_schedule(scheduler, IScheduler);
void {
    this: .active = true,
    this: .add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
        source: this, destination: this.destination, scheduler: scheduler
    }))
};
scheduleNotification(notification, Notification_1.Notification(), void {
    if: function () { }, this: .errored === true });
{
    return;
}
var scheduler = this.scheduler;
var message = new DelayMessage(scheduler.now() + this.delay, notification);
this.queue.push(message);
if (this.active === false) {
    this._schedule(scheduler);
}
_next(value, T);
{
    this.scheduleNotification(Notification_1.Notification.createNext(value));
}
_error(err, any);
{
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
}
_complete();
{
    this.scheduleNotification(Notification_1.Notification.createComplete());
}
var DelayMessage = (function () {
    function DelayMessage(readonly, number, readonly, Notification) {
        if (readonly === void 0) { readonly = time; }
        if (readonly === void 0) { readonly = notification; }
        if (Notification === void 0) { Notification = ; }
        this.readonly = readonly;
        this.readonly = readonly;
    }
    return DelayMessage;
}());
