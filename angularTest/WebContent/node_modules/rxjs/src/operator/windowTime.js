"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Action_1 = require('../scheduler/Action');
var Subject_1 = require('../Subject');
var Subscriber_1 = require('../Subscriber');
var Observable_1 = require('../Observable');
this;
Observable_1.Observable < T > , windowTimeSpan;
number,
    scheduler ?  : IScheduler;
Observable_1.Observable();
this;
Observable_1.Observable < T > , windowTimeSpan;
number,
    windowCreationInterval;
number,
    scheduler ?  : IScheduler;
Observable_1.Observable();
this;
Observable_1.Observable < T > , windowTimeSpan;
number,
    windowCreationInterval;
number,
    maxWindowSize;
number,
    scheduler ?  : IScheduler;
Observable_1.Observable();
this;
Observable_1.Observable < T > ,
    windowTimeSpan;
number;
Observable_1.Observable < Observable_1.Observable < T >> {
    let: scheduler, IScheduler: IScheduler,
    let: windowCreationInterval, number: number,
    let: maxWindowSize, number: number,
    if: function (isScheduler) {
        if (isScheduler === void 0) { isScheduler = (arguments[3]); }
        scheduler = arguments[3];
    },
    if: function (isScheduler) {
        if (isScheduler === void 0) { isScheduler = (arguments[2]); }
        scheduler = arguments[2];
    }, else: , if: function (isNumeric) {
        if (isNumeric === void 0) { isNumeric = (arguments[2]); }
        maxWindowSize = arguments[2];
    },
    if: function (isScheduler) {
        if (isScheduler === void 0) { isScheduler = (arguments[1]); }
        scheduler = arguments[1];
    }, else: , if: function (isNumeric) {
        if (isNumeric === void 0) { isNumeric = (arguments[1]); }
        windowCreationInterval = arguments[1];
    },
    return: this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler))
};
var WindowTimeOperator = (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        if (windowCreationInterval === void 0) { windowCreationInterval = null; }
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        _super.apply(this, arguments);
        this._numberOfNextedValues = 0;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject_1.Subject));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowTimeSubscriber = (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        if (windowCreationInterval === void 0) { windowCreationInterval = null; }
        _super.call(this, destination);
        this.destination = destination;
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
        this.windows = [];
        var window = this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };
            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber_1.Subscriber));
this;
Action_1.Action < TimeSpanOnlyState < T >> , state;
TimeSpanOnlyState();
void {
    const: (subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window, state),
    if: function (window) {
        subscriber.closeWindow(window);
    },
    state: .window = subscriber.openWindow(),
    this: .schedule(state, windowTimeSpan)
};
this;
Action_1.Action < CreationState < T >> , state;
CreationState();
void {
    const: (windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval, state),
    const: window = subscriber.openWindow(),
    const: action = this,
    let: context, CloseWindowContext: function () { } };
{
    action, subscription;
    null;
}
;
var timeSpanState = { subscriber: subscriber, window: window, context: context };
context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
action.add(context.subscription);
action.schedule(state, windowCreationInterval);
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}
